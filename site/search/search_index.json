{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Data Structures and Algorithms Written to prepare for technical interviews :)","title":"Data Structures and Algorithms"},{"location":"#data-structures-and-algorithms","text":"Written to prepare for technical interviews :)","title":"Data Structures and Algorithms"},{"location":"algorithms/dynamic-programming/","text":"Dynamic Programming Max Subset-Sum Given an array of integers, find the subset of non-adjacent elements with the maximum sum. Calculate the sum of that subset. def maxSubsetSum(arr): optSums = [0] * len(arr) optSums[0] = max(0, arr[0]) optSums[1] = max(0, arr[1]) for i in range(2, len(arr)): optSums[i] = max(0, arr[i]) + optSums[i-2] if optSums[i] < optSums[i-1]: optSums[i] = optSums[i-1] return optSums[-1] Formula: element may be negative (thus, never want to include). For each element, if you include, you cannot include previous element. Thus, OPT for element at index i is that element, plus the best up until i-2 th element, or the best up until i-1 . Candies Alice wants to give some candies to the children in her class. All the children sit in a line and each of them has a rating score. Alice wants to give at least 1 candy to each child. If two children sit next to each other, then the one with the higher rating must get more candies. Alice wants to minimize the total number of candies she must buy. def findNextMin(idx, n, arr): x = idx while x < n-1 and arr[x] > arr[x+1]: x += 1 return x def candies(n, arr): opt = [1] * n idx = 0 while idx < n-1: if arr[idx] > arr[idx+1]: nMin = findNextMin(idx, n, arr) for nIdx in range(idx, nMin): opt[nIdx] = max(opt[nIdx], nMin - nIdx + 1) idx = nMin elif arr[idx] < arr[idx+1]: opt[idx+1] = opt[idx]+1 idx += 1 elif arr[idx] == arr[idx+1]: idx += 1 return sum(opt) Longest Common Subsequence def commonChild(s1, s2): opt = [[0]*(len(s1) + 1) for i in range(len(s2) + 1)] for idx1 in range(1, len(s1)+1): for idx2 in range(1, len(s2)+1): useCurr = 0 if s1[idx1-1] == s2[idx2-1]: useCurr = opt[idx1-1][idx2-1] + 1 opt[idx1][idx2] = max(useCurr, opt[idx1][idx2-1], opt[idx1-1][idx2]) return opt[-1][-1]","title":"Dynamic Programming"},{"location":"algorithms/dynamic-programming/#dynamic-programming","text":"","title":"Dynamic Programming"},{"location":"algorithms/dynamic-programming/#max-subset-sum","text":"Given an array of integers, find the subset of non-adjacent elements with the maximum sum. Calculate the sum of that subset. def maxSubsetSum(arr): optSums = [0] * len(arr) optSums[0] = max(0, arr[0]) optSums[1] = max(0, arr[1]) for i in range(2, len(arr)): optSums[i] = max(0, arr[i]) + optSums[i-2] if optSums[i] < optSums[i-1]: optSums[i] = optSums[i-1] return optSums[-1] Formula: element may be negative (thus, never want to include). For each element, if you include, you cannot include previous element. Thus, OPT for element at index i is that element, plus the best up until i-2 th element, or the best up until i-1 .","title":"Max Subset-Sum"},{"location":"algorithms/dynamic-programming/#candies","text":"Alice wants to give some candies to the children in her class. All the children sit in a line and each of them has a rating score. Alice wants to give at least 1 candy to each child. If two children sit next to each other, then the one with the higher rating must get more candies. Alice wants to minimize the total number of candies she must buy. def findNextMin(idx, n, arr): x = idx while x < n-1 and arr[x] > arr[x+1]: x += 1 return x def candies(n, arr): opt = [1] * n idx = 0 while idx < n-1: if arr[idx] > arr[idx+1]: nMin = findNextMin(idx, n, arr) for nIdx in range(idx, nMin): opt[nIdx] = max(opt[nIdx], nMin - nIdx + 1) idx = nMin elif arr[idx] < arr[idx+1]: opt[idx+1] = opt[idx]+1 idx += 1 elif arr[idx] == arr[idx+1]: idx += 1 return sum(opt)","title":"Candies"},{"location":"algorithms/dynamic-programming/#longest-common-subsequence","text":"def commonChild(s1, s2): opt = [[0]*(len(s1) + 1) for i in range(len(s2) + 1)] for idx1 in range(1, len(s1)+1): for idx2 in range(1, len(s2)+1): useCurr = 0 if s1[idx1-1] == s2[idx2-1]: useCurr = opt[idx1-1][idx2-1] + 1 opt[idx1][idx2] = max(useCurr, opt[idx1][idx2-1], opt[idx1-1][idx2]) return opt[-1][-1]","title":"Longest Common Subsequence"},{"location":"algorithms/graph-algorithms/","text":"Graphs Breadth-First Search Implemented with adj. list format: def bfs(visited = set(), graph, node): #function for BFS visited.add(node) queue.append(node) while queue: node = queue.pop(0) for neighbour in graph[node]: if neighbour not in visited: visited.add(neighbour) queue.append(neighbour) Got from here . Uses: cycle detection in unweighted graph, GPS navigation, etc. Depth-First Search Implemented with adj. list format: def dfs(graph, start, target, path, visited = set()): path.append(start) visited.add(start) if start == target: return path for neighbour in graph[start]: if neighbour not in visited: result = dfs(adj_list, neighbour, target, path, visited) if result is not None: return result path.pop() # If we haven't returned by here, the current node is not on path to target. return None Got from here . Uses: Cycle detection Dijkstra's Algorithm","title":"Graphs"},{"location":"algorithms/graph-algorithms/#graphs","text":"","title":"Graphs"},{"location":"algorithms/graph-algorithms/#breadth-first-search","text":"Implemented with adj. list format: def bfs(visited = set(), graph, node): #function for BFS visited.add(node) queue.append(node) while queue: node = queue.pop(0) for neighbour in graph[node]: if neighbour not in visited: visited.add(neighbour) queue.append(neighbour) Got from here . Uses: cycle detection in unweighted graph, GPS navigation, etc.","title":"Breadth-First Search"},{"location":"algorithms/graph-algorithms/#depth-first-search","text":"Implemented with adj. list format: def dfs(graph, start, target, path, visited = set()): path.append(start) visited.add(start) if start == target: return path for neighbour in graph[start]: if neighbour not in visited: result = dfs(adj_list, neighbour, target, path, visited) if result is not None: return result path.pop() # If we haven't returned by here, the current node is not on path to target. return None Got from here . Uses: Cycle detection","title":"Depth-First Search"},{"location":"algorithms/graph-algorithms/#dijkstras-algorithm","text":"","title":"Dijkstra's Algorithm"},{"location":"algorithms/search/","text":"Searching Binary Search def binary_search(arr, low, high, x): if low == None: low = 0 if high == None: high = len(arr)-1 if high >= low: mid = (high + low) // 2 if arr[mid] == x: return mid elif arr[mid] > x: return binary_search(arr, low, mid - 1, x) else: return binary_search(arr, mid + 1, high, x) else: return -1 # Element is not present in the array","title":"Searching"},{"location":"algorithms/search/#searching","text":"","title":"Searching"},{"location":"algorithms/search/#binary-search","text":"def binary_search(arr, low, high, x): if low == None: low = 0 if high == None: high = len(arr)-1 if high >= low: mid = (high + low) // 2 if arr[mid] == x: return mid elif arr[mid] > x: return binary_search(arr, low, mid - 1, x) else: return binary_search(arr, mid + 1, high, x) else: return -1 # Element is not present in the array","title":"Binary Search"},{"location":"algorithms/sort/","text":"Sorting QuickSort def partition(arr, st, end): piv = arr[end] i = st - 1 for j in range(st, end + 1): if arr[j] <= piv: i += 1 arr[i], arr[j] = arr[j], arr[i] return i def quickSort(arr, st = 0, end = None): if end == None: end = len(arr) - 1 if (end - st) < 1: return i = partition(arr, st, end) quickSort(arr, st, i-1) quickSort(arr, i+1, end) MergeSort Divide array into 2 equal-sized subarrays Recursively sort subarrays Merge in one pass def mergeSort(arr): if len(arr) == 1: return mid = len(arr)//2 left = arr[:mid] right = arr[mid:] mergeSort(left) mergeSort(right) i = j = k = 0 while i < len(left) or j < len(right): if i >= len(left): arr[k] = right[j] j += 1 elif j >= len(right): arr[k] = left[i] i += 1 elif left[i] < right[j]: arr[k] = left[i] i += 1 else: # left[i] > right[j] arr[k] = right[j] j += 1 k += 1 return Bubble Sort def bubbleSort(a): for i in range(len(a)): for j in range(len(a)-1): if a[j] > a[j+1]: a[j], a[j+1] = a[j+1], a[j]","title":"Sorting"},{"location":"algorithms/sort/#sorting","text":"","title":"Sorting"},{"location":"algorithms/sort/#quicksort","text":"def partition(arr, st, end): piv = arr[end] i = st - 1 for j in range(st, end + 1): if arr[j] <= piv: i += 1 arr[i], arr[j] = arr[j], arr[i] return i def quickSort(arr, st = 0, end = None): if end == None: end = len(arr) - 1 if (end - st) < 1: return i = partition(arr, st, end) quickSort(arr, st, i-1) quickSort(arr, i+1, end)","title":"QuickSort"},{"location":"algorithms/sort/#mergesort","text":"Divide array into 2 equal-sized subarrays Recursively sort subarrays Merge in one pass def mergeSort(arr): if len(arr) == 1: return mid = len(arr)//2 left = arr[:mid] right = arr[mid:] mergeSort(left) mergeSort(right) i = j = k = 0 while i < len(left) or j < len(right): if i >= len(left): arr[k] = right[j] j += 1 elif j >= len(right): arr[k] = left[i] i += 1 elif left[i] < right[j]: arr[k] = left[i] i += 1 else: # left[i] > right[j] arr[k] = right[j] j += 1 k += 1 return","title":"MergeSort"},{"location":"algorithms/sort/#bubble-sort","text":"def bubbleSort(a): for i in range(len(a)): for j in range(len(a)-1): if a[j] > a[j+1]: a[j], a[j+1] = a[j+1], a[j]","title":"Bubble Sort"},{"location":"algorithms/tree-algorithms/","text":"Trees Binary Search Tree Validator class Solution(object): def isValidBST(self, node, min=None, max=None): if not node: # Validate the end of trees. return True if not min == None: if node.val <= min: return False if not max == None: if node.val >= max: return False leftValid = self.isValidBST(node.left, min, node.val) rightValid = self.isValidBST(node.right, node.val, max) return (leftValid and rightValid)","title":"Trees"},{"location":"algorithms/tree-algorithms/#trees","text":"","title":"Trees"},{"location":"algorithms/tree-algorithms/#binary-search-tree-validator","text":"class Solution(object): def isValidBST(self, node, min=None, max=None): if not node: # Validate the end of trees. return True if not min == None: if node.val <= min: return False if not max == None: if node.val >= max: return False leftValid = self.isValidBST(node.left, min, node.val) rightValid = self.isValidBST(node.right, node.val, max) return (leftValid and rightValid)","title":"Binary Search Tree Validator"},{"location":"data-structures/classes/","text":"Classes, Inheritance in Python class Mammal: def __init__(self, x, y): self.x = x self.y = y def walk(self): print(\u201cwalk\u201d) class Dog(Mammal): def bark(self): print(\u201cbark\u201d)","title":"Classes, Inheritance in Python"},{"location":"data-structures/classes/#classes-inheritance-in-python","text":"class Mammal: def __init__(self, x, y): self.x = x self.y = y def walk(self): print(\u201cwalk\u201d) class Dog(Mammal): def bark(self): print(\u201cbark\u201d)","title":"Classes, Inheritance in Python"},{"location":"data-structures/heaps-pqs/","text":"Heaps and Priority Queues The Heap Operation O-complexity isEmpty O(1) insert O(log(n)) extractMin/Max O(log(n)) min/max O(1) Implementation Python's Built-In: import heapq ... heapq.heapify(list) smallestElem = heapq.heappush(list, elem) # Add element heapq.heappop(list) # Remove element from the heap def heapsort(iterable): h = [] for value in iterable: heappush(h, value) return [heappop(h) for i in range(len(h))] DIY def min_heapify(A,k): l = left(k) r = right(k) if l < len(A) and A[l] < A[k]: smallest = l else: smallest = k if r < len(A) and A[r] < A[smallest]: smallest = r if smallest != k: A[k], A[smallest] = A[smallest], A[k] min_heapify(A, smallest) def left(k): return 2 * k + 1 def right(k): return 2 * k + 2 def build_min_heap(A): n = int((len(A)//2)-1) for k in range(n, -1, -1): min_heapify(A,k) A = [3,9,2,1,4,5] build_min_heap(A) print(A) Got from here . Priority Queue Implemented using max-heap. Uses: Looking for the top k items in a list Simulations, scheduling","title":"Heaps and Priority Queues"},{"location":"data-structures/heaps-pqs/#heaps-and-priority-queues","text":"","title":"Heaps and Priority Queues"},{"location":"data-structures/heaps-pqs/#the-heap","text":"Operation O-complexity isEmpty O(1) insert O(log(n)) extractMin/Max O(log(n)) min/max O(1)","title":"The Heap"},{"location":"data-structures/heaps-pqs/#implementation","text":"","title":"Implementation"},{"location":"data-structures/heaps-pqs/#pythons-built-in","text":"import heapq ... heapq.heapify(list) smallestElem = heapq.heappush(list, elem) # Add element heapq.heappop(list) # Remove element from the heap def heapsort(iterable): h = [] for value in iterable: heappush(h, value) return [heappop(h) for i in range(len(h))]","title":"Python's Built-In:"},{"location":"data-structures/heaps-pqs/#diy","text":"def min_heapify(A,k): l = left(k) r = right(k) if l < len(A) and A[l] < A[k]: smallest = l else: smallest = k if r < len(A) and A[r] < A[smallest]: smallest = r if smallest != k: A[k], A[smallest] = A[smallest], A[k] min_heapify(A, smallest) def left(k): return 2 * k + 1 def right(k): return 2 * k + 2 def build_min_heap(A): n = int((len(A)//2)-1) for k in range(n, -1, -1): min_heapify(A,k) A = [3,9,2,1,4,5] build_min_heap(A) print(A) Got from here .","title":"DIY"},{"location":"data-structures/heaps-pqs/#priority-queue","text":"Implemented using max-heap. Uses: Looking for the top k items in a list Simulations, scheduling","title":"Priority Queue"},{"location":"data-structures/lists/","text":"Lists Plain Ol' Lists In Python, if item in list takes a long time. Try to use if item in set when possible. Python built-in time complexities here . Linked Lists Operation O-complexity Space O(n) Pre-/append O(1) Lookup O(n) Insert O(n) Delete O(n) Ideal for implementing stacks and queues.","title":"Lists"},{"location":"data-structures/lists/#lists","text":"","title":"Lists"},{"location":"data-structures/lists/#plain-ol-lists","text":"In Python, if item in list takes a long time. Try to use if item in set when possible. Python built-in time complexities here .","title":"Plain Ol' Lists"},{"location":"data-structures/lists/#linked-lists","text":"Operation O-complexity Space O(n) Pre-/append O(1) Lookup O(n) Insert O(n) Delete O(n) Ideal for implementing stacks and queues.","title":"Linked Lists"},{"location":"data-structures/stacks-queues/","text":"Stacks and Queues Stacks Last In, First Out Operation O-complexity Push O(1) Pop O(1) Peek O(1) Uses: Call stack (of functions), depth first search Implementation Python's Built-In from collections import deque stack = deque() stack.append('c') stack.pop() DIY Implement as a linked list -- insert and remove at the head. class SLinkedList: def __init__(self): self.head = None self.rear = None def add_node(self, node): if (self.head == None): self.head = node else: ptr = self.head while self.next != None: ptr = self.next # Skip to end of list. ptr.next = node Queues First In, First Out Operation O-complexity Enqueue O(1) Dequeue O(1) Peek O(1) Uses: Breadth First Search, printers, web servers (replying to requests in order). Implementation Python's Built-In from collections import deque q = deque() q.append('c') q.popleft() DIY Implement as a linked list -- insert at the tail, remove at the head. class QueueLnkdLst: def __init__(self): self.head = None self.rear = None def enqueue(self, node): if (self.head == None): self.head = node self.rear = node else: self.rear.next = node self.rear = node Can also implement as an array, where you mantain pointers to head/rear of list, and bump accccordingly.","title":"Stacks and Queues"},{"location":"data-structures/stacks-queues/#stacks-and-queues","text":"","title":"Stacks and Queues"},{"location":"data-structures/stacks-queues/#stacks","text":"Last In, First Out Operation O-complexity Push O(1) Pop O(1) Peek O(1) Uses: Call stack (of functions), depth first search","title":"Stacks"},{"location":"data-structures/stacks-queues/#implementation","text":"","title":"Implementation"},{"location":"data-structures/stacks-queues/#pythons-built-in","text":"from collections import deque stack = deque() stack.append('c') stack.pop()","title":"Python's Built-In"},{"location":"data-structures/stacks-queues/#diy","text":"Implement as a linked list -- insert and remove at the head. class SLinkedList: def __init__(self): self.head = None self.rear = None def add_node(self, node): if (self.head == None): self.head = node else: ptr = self.head while self.next != None: ptr = self.next # Skip to end of list. ptr.next = node","title":"DIY"},{"location":"data-structures/stacks-queues/#queues","text":"First In, First Out Operation O-complexity Enqueue O(1) Dequeue O(1) Peek O(1) Uses: Breadth First Search, printers, web servers (replying to requests in order).","title":"Queues"},{"location":"data-structures/stacks-queues/#implementation_1","text":"","title":"Implementation"},{"location":"data-structures/stacks-queues/#pythons-built-in_1","text":"from collections import deque q = deque() q.append('c') q.popleft()","title":"Python's Built-In"},{"location":"data-structures/stacks-queues/#diy_1","text":"Implement as a linked list -- insert at the tail, remove at the head. class QueueLnkdLst: def __init__(self): self.head = None self.rear = None def enqueue(self, node): if (self.head == None): self.head = node self.rear = node else: self.rear.next = node self.rear = node Can also implement as an array, where you mantain pointers to head/rear of list, and bump accccordingly.","title":"DIY"},{"location":"data-structures/tables-maps-sets/","text":"Tables, Maps, and Sets Set (Abstract Data Type) Operation O-complexity Space O(n) Add(e) O(h) Contains(e) O(h) isEmpty O(1) Remove(e) O(h) Size O(1) Where h is the height of binary tree, if binary tree used for implementation. Python Implementation In Python, set implemented with hashtable. aSet = set() aSet.add(\"banana\") print(\"Banana in set:\", \"banana\" in aSet) for x in aSet: print x # iterate over values in set someItem = aSet.pop() # removes any item from the set. aSet.remove(\"banana\") # removes specific item. # aSet.discard(\"banana\") does not throw error on missing. bSet = {\"orange\"} union = aSet.union(bSet) # get union of sets intersection = aSet.intersection(bSet) aaSet = aSet.copy() # duplicate set print(\"Length is\", len(set)) # get length Map (Abstract Data Type) Operation O-complexity ContainsKey(key) O() ContainsVal(val) O() Get(key) O() isEmpty() O() keySet() O() put(key, val) O() remove(key) O() Hashtable Salting: multiplying the hash with a random integer so that even if a hacker knew what common passwords were and their corresponding hashes, they couldn't just map them. Open Addressing: * Insertion: go to the hash-slot, but keep iterating down until you find an open slot. * Retrieval: go to the hash-slot, but if it's not there, iterate until you hit a None box. * Deletion: when deleting, fill with a dummy-variable that isn't None that you know means can overwrite if insertion but pretend is full for purpose of retrieval. Amortized analysis : When we get the worst-case runtimes, i.e. because we're expanding the table, this will pay dividends in faster time later that get averaged out. Implementation Hard-coded: class Hashtable: def __init__(self, bucket_size): self.bucket_size = bucket_size self.buckets = [[] for i in range(self.bucket_size)] # create empty buckets def save_key_val_pair(self, key, value): hashed_val = hash(key) bIndex = hashed_val % self.bucket_size self.buckets[bIndex].append((key, value)) def get_value(self, key): hashed_value = hash(key) bIndex = hashed_value % self.bucket_size bucket = self.buckets[bIndex] for key, value in bucket: if key == input_key: return(value) return None Python Implementation Implemented using a hashtable. aDict = dict() aDict[\"a\"] = \"apple\" aDict.get(\"banana\", \"not there\") # get key (or default value) for key in aDict: # or \"for key in newDict.keys():\" print(key, aDict[key]) for (key, value) in aDict.items(): print(key, value) del dict[\"a\"] # delete key/value pair. print(len(aDict)) # get number of items","title":"Tables, Maps, and Sets"},{"location":"data-structures/tables-maps-sets/#tables-maps-and-sets","text":"","title":"Tables, Maps, and Sets"},{"location":"data-structures/tables-maps-sets/#set-abstract-data-type","text":"Operation O-complexity Space O(n) Add(e) O(h) Contains(e) O(h) isEmpty O(1) Remove(e) O(h) Size O(1) Where h is the height of binary tree, if binary tree used for implementation.","title":"Set (Abstract Data Type)"},{"location":"data-structures/tables-maps-sets/#python-implementation","text":"In Python, set implemented with hashtable. aSet = set() aSet.add(\"banana\") print(\"Banana in set:\", \"banana\" in aSet) for x in aSet: print x # iterate over values in set someItem = aSet.pop() # removes any item from the set. aSet.remove(\"banana\") # removes specific item. # aSet.discard(\"banana\") does not throw error on missing. bSet = {\"orange\"} union = aSet.union(bSet) # get union of sets intersection = aSet.intersection(bSet) aaSet = aSet.copy() # duplicate set print(\"Length is\", len(set)) # get length","title":"Python Implementation"},{"location":"data-structures/tables-maps-sets/#map-abstract-data-type","text":"Operation O-complexity ContainsKey(key) O() ContainsVal(val) O() Get(key) O() isEmpty() O() keySet() O() put(key, val) O() remove(key) O()","title":"Map (Abstract Data Type)"},{"location":"data-structures/tables-maps-sets/#hashtable","text":"Salting: multiplying the hash with a random integer so that even if a hacker knew what common passwords were and their corresponding hashes, they couldn't just map them. Open Addressing: * Insertion: go to the hash-slot, but keep iterating down until you find an open slot. * Retrieval: go to the hash-slot, but if it's not there, iterate until you hit a None box. * Deletion: when deleting, fill with a dummy-variable that isn't None that you know means can overwrite if insertion but pretend is full for purpose of retrieval. Amortized analysis : When we get the worst-case runtimes, i.e. because we're expanding the table, this will pay dividends in faster time later that get averaged out.","title":"Hashtable"},{"location":"data-structures/tables-maps-sets/#implementation","text":"","title":"Implementation"},{"location":"data-structures/tables-maps-sets/#hard-coded","text":"class Hashtable: def __init__(self, bucket_size): self.bucket_size = bucket_size self.buckets = [[] for i in range(self.bucket_size)] # create empty buckets def save_key_val_pair(self, key, value): hashed_val = hash(key) bIndex = hashed_val % self.bucket_size self.buckets[bIndex].append((key, value)) def get_value(self, key): hashed_value = hash(key) bIndex = hashed_value % self.bucket_size bucket = self.buckets[bIndex] for key, value in bucket: if key == input_key: return(value) return None","title":"Hard-coded:"},{"location":"data-structures/tables-maps-sets/#python-implementation_1","text":"Implemented using a hashtable. aDict = dict() aDict[\"a\"] = \"apple\" aDict.get(\"banana\", \"not there\") # get key (or default value) for key in aDict: # or \"for key in newDict.keys():\" print(key, aDict[key]) for (key, value) in aDict.items(): print(key, value) del dict[\"a\"] # delete key/value pair. print(len(aDict)) # get number of items","title":"Python Implementation"},{"location":"data-structures/trees/","text":"Binary Trees A complete tree : nodes filled in left to right, all but last level are full. log_2(n+1)=h, where n = number of nodes, h = tree height. (round up!) Visiting In Order: # In Node class def visitInOrder(self): if self.left: self.left.visitInOrder() print(self.val) # Do whatever you want to do. if self.right: right.visitInOrder()","title":"Trees"},{"location":"data-structures/trees/#binary-trees","text":"A complete tree : nodes filled in left to right, all but last level are full. log_2(n+1)=h, where n = number of nodes, h = tree height. (round up!) Visiting In Order: # In Node class def visitInOrder(self): if self.left: self.left.visitInOrder() print(self.val) # Do whatever you want to do. if self.right: right.visitInOrder()","title":"Binary Trees"},{"location":"tips-and-conventions/python-tips/","text":"Style Points and Helpful Code Unpacking for i, item in enumerate(some_list): # do something. # enumerate --> returns count of where you are + item. Swapping a, b = b, a Create a length-N list of the same thing four_nones = [None] * 4 If an object is mutable -- this will copy 4 references to list. Create a length-N list of lists four_lists = [[] for __ in range(4)] Check style pip install pycodestyle pycodestyle program.py None evaluates to False (Falsey). Can use is None if need to distinguish between False , None . Else, if element or if not element is fine. Remove from list while i in a: a.remove(i) List Comprehension # Creates a new list object of filtered vals. filtered_values = [value for value in sequence if value != x] # Opening Files with open('file.txt') as f: for line in f: print(line) Always handles exceptions, and closes. \"We are all responsible users\" No such thing as \"private\" in Python. Use 4 spaces per indentation level. F Strings def greet_user(name): print(f\u201dHi {name}\u201d) How to Do Random Variables import random random.random() # returns a float between 0 to 1 random.randint(1, 6) # returns an int between 1 to 6","title":"Style Points and Helpful Code"},{"location":"tips-and-conventions/python-tips/#style-points-and-helpful-code","text":"","title":"Style Points and Helpful Code"},{"location":"tips-and-conventions/python-tips/#unpacking","text":"for i, item in enumerate(some_list): # do something. # enumerate --> returns count of where you are + item.","title":"Unpacking"},{"location":"tips-and-conventions/python-tips/#swapping","text":"a, b = b, a","title":"Swapping"},{"location":"tips-and-conventions/python-tips/#create-a-length-n-list-of-the-same-thing","text":"four_nones = [None] * 4 If an object is mutable -- this will copy 4 references to list.","title":"Create a length-N list of the same thing"},{"location":"tips-and-conventions/python-tips/#create-a-length-n-list-of-lists","text":"four_lists = [[] for __ in range(4)]","title":"Create a length-N list of lists"},{"location":"tips-and-conventions/python-tips/#check-style","text":"pip install pycodestyle pycodestyle program.py","title":"Check style"},{"location":"tips-and-conventions/python-tips/#none-evaluates-to-false-falsey","text":"Can use is None if need to distinguish between False , None . Else, if element or if not element is fine.","title":"None evaluates to False (Falsey)."},{"location":"tips-and-conventions/python-tips/#remove-from-list","text":"while i in a: a.remove(i)","title":"Remove from list"},{"location":"tips-and-conventions/python-tips/#list-comprehension","text":"# Creates a new list object of filtered vals. filtered_values = [value for value in sequence if value != x] #","title":"List Comprehension"},{"location":"tips-and-conventions/python-tips/#opening-files","text":"with open('file.txt') as f: for line in f: print(line) Always handles exceptions, and closes.","title":"Opening Files"},{"location":"tips-and-conventions/python-tips/#we-are-all-responsible-users","text":"No such thing as \"private\" in Python.","title":"\"We are all responsible users\""},{"location":"tips-and-conventions/python-tips/#use-4-spaces-per-indentation-level","text":"","title":"Use 4 spaces per indentation level."},{"location":"tips-and-conventions/python-tips/#f-strings","text":"def greet_user(name): print(f\u201dHi {name}\u201d)","title":"F Strings"},{"location":"tips-and-conventions/python-tips/#how-to-do-random-variables","text":"import random random.random() # returns a float between 0 to 1 random.randint(1, 6) # returns an int between 1 to 6","title":"How to Do Random Variables"},{"location":"tips-and-conventions/regex/","text":"\"a\" matches letter a. \"cat\" matches string \"cat\". \"a|i|e|o|u\" matches any vowel. \"c(a|o)t\" matches cat or cot. \"[a-z]\" matches any character in range. \"[^a-z]\" matches anything not in range. \"a+\" matches any non-zero number of instances. \"a*\" matches zero-or-more.","title":"Regex"}]}